package com.inn.counselling.utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.cxf.jaxrs.ext.search.ConditionType;

/**
 * The QueryObject is used to pass search parameters to the DAO layer. This
 * is an encapsulation of search criteria, which is interpreted by underlying 
 * DAO implementer to construct a query.
 *
 * By having all the search parameters in one place (the QueryObject), this
 * prevents combinatory explosion of 'find' method signatures viz findByXXX in the DAO/Service layer.
 * This leads to a more stable DAO/Service interfaces as one can add search parameters to the
 * QueryObject without adding new methods to interfaces.
 *
 * QueryObject helps you drive your search in the following areas:
 * <ul>
 * <li>Configure the search mode (EQUALS, LIKE, ...)</li>
 * <li>Pagination: it allows to limit search results to a specific range.</li>
 * <li>Allows to specify ORDER BY and ASC/DESC</li>
 * <li>Simple support for date range search criteria</li>
 * <li>Named query: if you set a named query, it will be executed</li>
 * </ul>
 * 
 * @author Auto Generated By HeadStart
 * @version 1.0
 */
public class QueryObject implements Cloneable {
	/**
	 * represents the sorting order ascending or descending.
	 */
	public static enum SortOrder{ASC, DESC}
	/**
	 * represents the mode of comparing when searching.
	 */
	public static enum SearchMode{LIKE, EQUAL, NOT_EQUAL, IS_NULL, BETWEEN, IN,GREATER_THAN
	
, LESS_THAN,GREATER_OR_EQUAL

, LESS_OR_EQUAL;
	public static SearchMode getSearchMode(ConditionType conditionType){
		SearchMode mode = EQUAL;	
		switch(conditionType){
			 case EQUALS:
				 mode = EQUAL;
				 break;
			 case NOT_EQUALS:
				 mode = NOT_EQUAL;
				 break;
			 case LESS_THAN:
				 mode = LESS_THAN;
				 break;
			 case GREATER_THAN:
				 mode = GREATER_THAN;
				 break;
			 case LESS_OR_EQUALS:
				 mode = LESS_OR_EQUAL;
				 break;
			 case GREATER_OR_EQUALS:
				 mode = GREATER_OR_EQUAL;
			 break;
			 case OR:
			 case AND:
			 case CUSTOM:
			}
			return mode ;
		}
	}
	/**
	 * represents the search mode for specified field name.
	 */
	private Map<String, SearchMode> fieldNameModeMapping = new HashMap<String, QueryObject.SearchMode>();
	/**
	 * represents the place holder for searched values mapped with respective field name. 
	 */
	private Map<String, Object> fieldNameValueMapping = new HashMap<String, Object>();
	
	private List<SearchFilterWrapper> filterWrapper = new ArrayList<SearchFilterWrapper>();
	
	public void addValueForFilterWrapper(SearchFilterWrapper wrapper){
		filterWrapper.add(wrapper);
	}
	
	public List<SearchFilterWrapper> getSearchFilterWrapperList(){
		return filterWrapper;
	}
	/**
	 * represents the upper limit for pagination.
	 */
	private long paginationUpperLimit = -1;
	/**
	 * represents the lower limit for pagination.
	 */
	private long paginationLowerLimit = -1;
	/**
	 * represents the ordering of results for different column.
	 */
	private Map<String, SortOrder> orderByMode;
	/**
	 * This query depends on isPaged() API. The property of this API 
	 * shall only be used when isPaged returns true.
	 * @return returns the last item index. 
	 */
	public long getPaginationUpperLimit(){
		return paginationUpperLimit;
	}
	/**
	 * This query depends on isPaged() API. The property of this API 
	 * shall only be used when isPaged returns true.
	 * @return returns the first item index.
	 */
	public long getPaginationLowerLimit(){
		return paginationLowerLimit;
	}
	/**
	 * represents an order pair of min and max value.
	 */
	public static class MinMax implements Cloneable{
		/**
		 * minimum value
		 */
		private long min;
		/**
		 * maximum value
		 */
		private long max;
		public long getMin() {
			return min;
		}
		public void setMin(long min) {
			this.min = min;
		}
		public long getMax() {
			return max;
		}
		public void setMax(long max) {
			this.max = max;
		}
		public MinMax(long min, long max) {
			super();
			this.min = min;
			this.max = max;
		}

	}
	/**
	 * @param key represents the field name.
	 * @return returns search value for the given field name 
	 */
	public Object getValueByFieldName(String key){
		if(this.fieldNameValueMapping == null)
		{
			return null;
			}
		else
		{
			return this.fieldNameValueMapping.get(key);
			}
	}
	/**
	 * Sets the value to be looked up for a given field.
	 * @param fieldName represents the field name on which result needs to be filtered.
	 * @param object represents the associated value to be looked up.
	 */
	public void setValueForFieldName(String fieldName, Object object){
		if(this.fieldNameValueMapping == null)
		{
			this.fieldNameValueMapping = new HashMap<String, Object>();
		}
		this.fieldNameValueMapping.put(fieldName, object);
	}
	/**
	 * @param key represents the field name.
	 * @return returns the search mode by which the value needs to be compared.
	 */
	public SearchMode getModeByFieldName(String key){
		if(this.fieldNameModeMapping == null)
		{
			return null;
			}
		else
		{
			return this.fieldNameModeMapping.get(key);
			}
	}
	/**
	 * sets the search mode for the field.
	 * @param fieldName
	 * @param mode
	 */
	public void setModeForFieldName(String fieldName, SearchMode mode){
		if(this.fieldNameModeMapping == null)
		{
			this.fieldNameModeMapping = new HashMap<String, SearchMode>();
			}
		this.fieldNameModeMapping.put(fieldName, mode);
	}
	/**
	 * adds an order by clause for a particular field.
	 * @param fieldName
	 * @param order
	 */
	public void addOrderingClause(String fieldName, SortOrder order){
		if(getOrderByMode()==null){
			setOrderByMode(new HashMap<String, QueryObject.SortOrder>());
		}
		getOrderByMode().put(fieldName, order);
	}
	/**
	 * @return returns the field and search mode mapping as Map.
	 */
	public Map<String, SearchMode> getFieldNameModeMapping() {
		return fieldNameModeMapping;
	}
	/**
	 * sets the field search mode mapping for this query object.
	 * @param fieldNameModeMapping
	 */
	public void setFieldNameModeMapping(Map<String, SearchMode> fieldNameModeMapping) {
		this.fieldNameModeMapping = fieldNameModeMapping;
	}
	/**
	 * @return returns the field and there respective values as Map.
	 */
	public Map<String, Object> getFieldNameValueMapping() {
		return fieldNameValueMapping;
	}
	/**
	 * sets the field and with there respective values.
	 * @param fieldNameValueMapping
	 */
	public void setFieldNameValueMapping(Map<String, Object> fieldNameValueMapping) {
		this.fieldNameValueMapping = fieldNameValueMapping;
	}
	/**
	 * @return
	 */
	public Map<String, SortOrder> getOrderByMode() {
		return orderByMode;
	}
	/**
	 * sets the upper bound limit of pagination.
	 * @param paginationUpperLimit
	 */
	public void setPaginationUpperLimit(long paginationUpperLimit) {
		this.paginationUpperLimit = paginationUpperLimit;
	}
	/**
	 * sets the lower bound limit of pagination.
	 * @param paginationLowerLimit
	 */
	public void setPaginationLowerLimit(long paginationLowerLimit) {
		this.paginationLowerLimit = paginationLowerLimit;
	}
	
	/**
	 * sets the field and its respective order.
	 * @param orderByMode
	 */
	public void setOrderByMode(Map<String, SortOrder> orderByMode) {
		this.orderByMode = orderByMode;
	}
	@Override
	public String toString() {
		String eol = System.getProperty("line.separator");
		return "FieldName-Mode Mapping " + getFieldNameModeMapping() +eol+
		"FieldName-Value Mapping " + getFieldNameValueMapping() +eol+
		"Pagination Lower Limit"+getPaginationLowerLimit() +eol+
		"Pagination Upper Limit"+getPaginationUpperLimit() +eol;
	}
}
